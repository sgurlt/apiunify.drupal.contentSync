<?php

/**
 * @file
 * Module file for drupal_content_sync.
 */

use Drupal\Core\Entity\ContentEntityForm;
use Drupal\Core\Form\FormStateInterface;
use Drupal\encrypt\Entity\EncryptionProfile;
use Drupal\Core\Entity\EntityInterface;
use Drupal\drupal_content_sync\Entity\DrupalContentSync;
use Drupal\Core\Url;
use Drupal\Core\Render\Element;
use Drupal\Core\Entity\ContentEntityDeleteForm;
use Drupal\drupal_content_sync\SyncResult\SuccessResult;

define('DRUPAL_CONTENT_SYNC_PROFILE_NAME', 'drupal_content_sync');

/**
 * @param $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param $form_id
 */
function drupal_content_sync_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form_object = $form_state->getFormObject();

  if ($form_object instanceof ContentEntityDeleteForm) {
    if ($form_state->getUserInput()['confirm']) {
      return;
    }
    $entity = $form_object->getEntity();
    $sync   = DrupalContentSync::getExportSynchronizationForEntity($entity, DrupalContentSync::EXPORT_AUTOMATICALLY);

    if ($sync && $sync->delete_entities) {
      drupal_set_message(t('This will delete the %type from all sites using it.', [
        '%type' => $entity->getEntityTypeId(),
      ]), 'error');
    }
  }

  switch ($form_id) {
    case 'user_form':
      $form['actions']['submit']['#submit'][] = 'drupal_content_sync_user_password_submit';
      break;
  }

  _drupal_content_sync_form_alter_disabled_fields($form, $form_state, $form_id);
}

/**
 *
 */
function _drupal_content_sync_get_user_email() {
  // @TODO Make this configurable
  return 'developer@brightsolutions.de';
}

/**
 * Implements hook_entity_insert().
 */
function drupal_content_sync_entity_insert(EntityInterface $entity) {
  $sync = DrupalContentSync::getExportSynchronizationForEntity($entity, DrupalContentSync::EXPORT_AUTOMATICALLY);
  if ($sync) {
    $status = $sync->exportEntity($entity, DrupalContentSync::EXPORT_AUTOMATICALLY, DrupalContentSync::ACTION_CREATE);
    if ($status->successful()) {
      if ($status->code == SuccessResult::CODE_SUCCESS) {
        drupal_set_message(t('%label has been exported automatically with Drupal Content Sync.', ['%label' => $entity->label()]));
      }
    }
    elseif ($status->exception) {
      drupal_set_message(t('Failed to export %label automatically with Drupal Content Sync (%code). Message: %message', ['%label' => $entity->label(), '%code' => $status->code, '%message' => $status->exception->getMessage()]), 'warning');
    }
    else {
      drupal_set_message(t('Failed to export %label automatically with Drupal Content Sync (%code).', ['%label' => $entity->label(), '%code' => $status->code]), 'warning');
    }
  }
}

/**
 * Implements hook_entity_update().
 */
function drupal_content_sync_entity_update(EntityInterface $entity) {
  $sync = DrupalContentSync::getExportSynchronizationForEntity($entity, DrupalContentSync::EXPORT_AUTOMATICALLY);
  if ($sync) {
    // This is actually an update, but for the case this entity existed
    // before the synchronization was created or the entity could not be
    // exported before for any reason, using ::ACTION_UPDATE would lead to
    // errors. Thus we're just using ::ACTION_CREATE which always works.
    $status = $sync->exportEntity($entity, DrupalContentSync::EXPORT_AUTOMATICALLY, DrupalContentSync::ACTION_CREATE);
    if ($status->successful()) {
      if ($status->code == SuccessResult::CODE_SUCCESS) {
        drupal_set_message(t('%label has been exported automatically with Drupal Content Sync.', ['%label' => $entity->label()]));
      }
    }
    elseif ($status->exception) {
      drupal_set_message(t('Failed to export %label automatically with Drupal Content Sync (%code). Message: %message', ['%label' => $entity->label(), '%code' => $status->code, '%message' => $status->exception->getMessage()]), 'warning');
    }
    else {
      drupal_set_message(t('Failed to export %label automatically with Drupal Content Sync (%code).', ['%label' => $entity->label(), '%code' => $status->code]), 'warning');
    }
  }
}

/**
 * Implements hook_entity_delete().
 */
function drupal_content_sync_entity_delete(EntityInterface $entity) {
  $sync = DrupalContentSync::getExportSynchronizationForEntity($entity, DrupalContentSync::EXPORT_AUTOMATICALLY);
  if ($sync) {
    $status = $sync->exportEntity($entity, DrupalContentSync::EXPORT_AUTOMATICALLY, DrupalContentSync::ACTION_DELETE);
    if ($status->successful()) {
      if ($status->code == SuccessResult::CODE_SUCCESS) {
        drupal_set_message(t('Deletion of %label has been exported automatically with Drupal Content Sync.', ['%label' => $entity->label()]));
      }
    }
    elseif ($status->exception) {
      drupal_set_message(t('Failed to export deletion of %label automatically with Drupal Content Sync (%code). Message: %message', ['%label' => $entity->label(), '%code' => $status->code, '%message' => $status->exception->getMessage()]), 'warning');
    }
    else {
      drupal_set_message(t('Failed to export deletion of %label automatically with Drupal Content Sync (%code).', ['%label' => $entity->label(), '%code' => $status->code]), 'warning');
    }
  }
}

/**
 *
 */
function drupal_content_sync_user_password_submit(&$form, FormStateInterface $form_state) {
  $mail = $form_state->getValue('mail');

  if (_drupal_content_sync_get_user_email() == $mail) {
    $new_data = [
      'userName' => $form_state->getValue('name'),
      'userPass' => $form_state->getValue('pass'),
    ];

    // If password wasn't changed then value will be empty and we don't need it.
    $new_data = array_filter($new_data);
    $new_data = drupal_content_sync_encrypt_values($new_data);

    $userId   = $form_state->getValue('uid');
    $userData = \Drupal::service('user.data');

    $old_data = $userData->get('drupal_content_sync', $userId, 'sync_data');
    $new_data = array_replace($old_data, $new_data);

    $userData->set('drupal_content_sync', $userId, 'sync_data', $new_data);

    $synchronisations = DrupalContentSync::getAll();

    foreach ($synchronisations as $synchronisation) {
      $synchronisation->save();
    }
  }
}

/**
 *
 */
function drupal_content_sync_encrypt_values(array $values) {
  $encryption_profile = EncryptionProfile::load(DRUPAL_CONTENT_SYNC_PROFILE_NAME);

  foreach ($values as $key => $value) {
    $values[$key] = \Drupal::service('encryption')
      ->encrypt($value, $encryption_profile);
  }

  return $values;
}

/**
 * @param $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param $form_id
 */
function _drupal_content_sync_form_alter_disabled_fields(&$form, FormStateInterface $form_state, $form_id) {
  $form_object = $form_state
    ->getFormObject();

  if (!($form_object instanceof ContentEntityForm)) {
    return;
  }

  $entity = $form_object
    ->getEntity();

  // @TODO Check why this is NULL
  if (!$entity) {
    return;
  }

  // @TODO: Disable editing only if meta says entity is NOT CLONED
  // $meta = ***load_meta_info***($entity);
  // if( !$meta || $meta->isCloned() ) {
  //  return;
  // }
  $sync = DrupalContentSync::getImportSynchronizationForEntityType($entity->getEntityType(), $entity->bundle(), DrupalContentSync::IMPORT_FORCED);
  if (!$sync) {
    return;
  }

  $config = $sync->getEntityTypeConfig($entity->getEntityType(), $entity->bundle());

  if (!empty($config['handler_settings']['restrict_editing'])) {
    $drupal_content_synched_value = $entity->get('field_drupal_content_synced')->getValue();
    $field_drupal_content_synce_value = reset($drupal_content_synched_value);

    if (isset($field_drupal_content_synce_value['value']) && '1' === $field_drupal_content_synce_value['value']) {
      foreach ($form as $key => $form_item) {
        if (0 === strpos($key, 'field_') || (is_array($form_item) && isset($form_item['#type']) && 'container' === $form_item['#type'])) {
          $form[$key]['#disabled'] = TRUE;
        }
      }

      drupal_set_message(t('The entity cannot be edited because it has been synced.'), 'warning');
    }
  }
}

/**
 * Implements hook_theme().
 *
 * @return array
 */
function drupal_content_sync_theme() {
  $theme['drupal_content_sync_content_dashboard'] = [
    'variables' => ['configuration' => NULL],
    'template' => 'drupal_content_sync_content_dashboard',
  ];

  return $theme;
}

/**
 * Implements hook_entity_operation_alter().
 */
function drupal_content_sync_entity_operation_alter(array &$operations, EntityInterface $entity) {
  $operations += drupal_content_sync_get_publish_changes_operations($entity);
}

/**
 * Returns operations for "publish changes" action.
 */
function drupal_content_sync_get_publish_changes_operations(EntityInterface $entity) {
  /** @var \Drupal\Core\Routing\RedirectDestinationInterface $redirect_destination */
  $redirect_destination = Drupal::service('redirect.destination');

  $sync = DrupalContentSync::getExportSynchronizationForEntity($entity, DrupalContentSync::EXPORT_MANUALLY);

  if (!$sync) {
    return [];
  }

  $route_parameters = [
    'sync_id' => $sync->id(),
    'entity_type' => $entity->getEntityTypeId(),
    'entity' => $entity->id(),
  ];

  $operations['publish_changes'] = [
    'title' => t('Publish changes'),
    'weight' => 150,
    'url' => Url::fromRoute('drupal_content_sync.publish_changes', $route_parameters),
    'query' => $redirect_destination->getAsArray(),
  ];

  return $operations;
}

/**
 * Implements hook_form_menu_edit_form_alter().
 */
function drupal_content_sync_form_menu_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // @TODO Refactor => usage?

  $links = [];
  if (!empty($form['links']['links'])) {
    $links = Element::children($form['links']['links']);
  }
  foreach ($links as $link_key) {
    $link = $form['links']['links'][$link_key];

    /** @var \Drupal\menu_link_content\Plugin\Menu\MenuLinkContent $menu_link */
    $menu_link = $link['#item']->link;
    if (!method_exists($menu_link, 'getEntity')) {
      continue;
    }

    // We need to get an Entity at this point,
    // but 'getEntity' is protected for some reason.
    // So we don't have other choice here but use a reflection.
    $menu_link_reflection = new ReflectionMethod('\Drupal\menu_link_content\Plugin\Menu\MenuLinkContent', 'getEntity');
    $menu_link_reflection->setAccessible(TRUE);
    $menu_link_entity = $menu_link_reflection->invoke($menu_link, 'getEntity');

    $form['links']['links'][$link_key]['operations']['#links'] += drupal_content_sync_get_publish_changes_operations($menu_link_entity);
  }
}
