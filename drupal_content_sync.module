<?php

/**
 * @file
 * Module file for drupal_content_sync.
 *
 * @author Edge Box GmbH
 */

use Drupal\drupal_content_sync\Exception\SyncException;
use Drupal\Core\Entity\ContentEntityForm;
use Drupal\Core\Form\FormStateInterface;
use Drupal\encrypt\Entity\EncryptionProfile;
use Drupal\Core\Entity\EntityInterface;
use Drupal\drupal_content_sync\Entity\DrupalContentSync;
use Drupal\Core\Url;
use Drupal\Core\Render\Element;
use Drupal\Core\Entity\ContentEntityDeleteForm;
use Drupal\drupal_content_sync\Entity\DrupalContentSyncMetaInformation;

/**
 * @var int DRUPAL_CONTENT_SYNC_USER_ID The user to perform updates with.
 */
define('DRUPAL_CONTENT_SYNC_USER_ID', \Drupal::service('keyvalue.database')->get('drupal_content_sync_user')->get('uid'));
/**
 * @var string DRUPAL_CONTENT_SYNC_PROFILE_NAME The encryption profile name.
 */
define('DRUPAL_CONTENT_SYNC_PROFILE_NAME', 'drupal_content_sync');

/**
 * 1) Make sure the user is informed that content will not only be deleted on
 * this * instance but also on all connected instances if configured that way.
 *
 * 2) Make sure API Unify knows about password changes at the
 * Drupal Content Sync user and can still authenticate to perform updates.
 *
 * 3) Disabled node forms if the content has been imported and the
 * synchronization is configured to disable imported content.
 *
 * @see _drupal_content_sync_form_alter_disabled_fields
 *
 * @param array $form
 *   The form definition.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param string $form_id
 *   he ID of the form.
 */
function drupal_content_sync_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form_object = $form_state->getFormObject();

  if ($form_object instanceof ContentEntityDeleteForm) {
    if (!empty($form_state->getUserInput()['confirm'])) {
      return;
    }

    $entity = $form_object->getEntity();

    if( !DrupalContentSync::isLocalDeletionAllowed($entity) ) {
      $messenger = \Drupal::messenger();
      $messenger->addWarning(
        t(
          '%label cannot be deleted as it has been imported.',
          ['%label' => $entity->label()]
        )
      );
      // ['actions']['submit']
      $form['#disabled'] = TRUE;
    }
    else {
      $sync = DrupalContentSync::getExportSynchronizationForEntity(
        $entity,
        DrupalContentSync::EXPORT_AUTOMATICALLY,
        DrupalContentSync::ACTION_DELETE
      );
      if(!$sync) {
        $sync = DrupalContentSync::getExportSynchronizationForEntity(
          $entity,
          DrupalContentSync::EXPORT_AS_DEPENDENCY,
          DrupalContentSync::ACTION_DELETE
        );
        if($sync) {
          $info = DrupalContentSyncMetaInformation::getInfoForEntity(
            $entity->getEntityTypeId(),
            $entity->uuid()
          )[$sync->id];
          if(!$info || !$info->getLastExport()) {
            $sync = NULL;
          }
        }
      }

      if ($sync) {
        $messenger = \Drupal::messenger();
        $messenger->addWarning(
          t(
            'This will delete %label from all sites using it.',
            ['%label' => $entity->label()]
          )
        );
      }
    }
  }

  switch ($form_id) {
    case 'user_form':
      $form['actions']['submit']['#submit'][] = 'drupal_content_sync_user_password_submit';
      break;
  }

  _drupal_content_sync_form_alter_disabled_fields($form, $form_state, $form_id);
}

/**
 * Helper function to export an entity and display the user the results. If you
 * want to make changes programmatically, create your own handler instead.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity to export.
 * @param string $reason
 *   {@see DrupalContentSync::EXPORT_*}.
 * @param string $action
 *   {@see DrupalContentSync::ACTION_*}.
 * @param \Drupal\drupal_content_sync\Entity\DrupalContentSync $sync
 *   The sync to be used. First matching sync will be used if none is given.
 */
function _drupal_content_sync_export_entity(EntityInterface $entity, $reason, $action, DrupalContentSync $sync = NULL) {
  if (!$sync) {
    $sync = DrupalContentSync::getExportSynchronizationForEntity($entity, $reason, $action);
    if(!$sync) {
      // If this entity has been exported as a dependency, we want to export the
      // Update and deletion automatically as well.
      if($reason==DrupalContentSync::EXPORT_AUTOMATICALLY &&
        $action!=DrupalContentSync::ACTION_CREATE) {
        $sync = DrupalContentSync::getExportSynchronizationForEntity(
          $entity,
          DrupalContentSync::EXPORT_AS_DEPENDENCY,
          $action
        );
        if($sync) {
          $info = DrupalContentSyncMetaInformation::getInfoForEntity(
            $entity->getEntityTypeId(),
            $entity->uuid()
          )[$sync->id];
          if(!$info || !$info->getLastExport()) {
            return;
          }
        }
        else {
          return;
        }
      }
      else {
        return;
      }
    }
  }

  $messenger = \Drupal::messenger();
  try {
    $status = $sync->exportEntity($entity, $reason, $action);

    if ($status) {
      $messenger->addMessage(t('%label has been exported with Drupal Content Sync.', ['%label' => $entity->label()]));
    }
  }
  catch (SyncException $e) {
    $message = $e->parentException ? $e->parentException->getMessage() : (
      $e->errorCode == $e->getMessage() ? '' : $e->getMessage()
    );
    if ($message) {
      $messenger->addWarning(t('Failed to export %label with Drupal Content Sync (%code). Message: %message', [
        '%label' => $entity->label(),
        '%code' => $e->errorCode,
        '%message' => $message,
      ]));
    }
    else {
      $messenger->addWarning(t('Failed to export %label with Drupal Content Sync (%code).', [
        '%label' => $entity->label(),
        '%code' => $e->errorCode,
      ]));
    }
  }
}

/**
 * Export the entity automatically if configured to do so.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 */
function drupal_content_sync_entity_insert(EntityInterface $entity) {
  _drupal_content_sync_export_entity($entity, DrupalContentSync::EXPORT_AUTOMATICALLY, DrupalContentSync::ACTION_CREATE);
}

/**
 * Export the entity automatically if configured to do so.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 */
function drupal_content_sync_entity_update(EntityInterface $entity) {
  // This is actually an update, but for the case this entity existed
  // before the synchronization was created or the entity could not be
  // exported before for any reason, using ::ACTION_UPDATE would lead to
  // errors. Thus we're just using ::ACTION_CREATE which always works.
  _drupal_content_sync_export_entity($entity, DrupalContentSync::EXPORT_AUTOMATICALLY, DrupalContentSync::ACTION_UPDATE);
}

/**
 * Export the entity deletion automatically if configured to do so.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *
 * @throws \Exception If this entity has been imported and local deletion is
 *   forbidden, this will throw an error.
 */
function drupal_content_sync_entity_delete(EntityInterface $entity) {
  if( !DrupalContentSync::isLocalDeletionAllowed($entity) &&
    !DrupalContentSync::entityHasBeenImportedByRemote($entity) ) {
    throw new \Exception($entity->label().' cannot be deleted as it has been imported.');
  }

  _drupal_content_sync_export_entity($entity, DrupalContentSync::EXPORT_AUTOMATICALLY, DrupalContentSync::ACTION_DELETE);
}

/**
 * Implements hook_entity_translation_delete().
 */
function drupal_content_sync_entity_translation_delete(\Drupal\Core\Entity\EntityInterface $translation) {
  _drupal_content_sync_export_entity($translation, DrupalContentSync::EXPORT_AUTOMATICALLY, DrupalContentSync::ACTION_DELETE_TRANSLATION);
}

/**
 * Update the password at API Unify if it's necessary for authentication.
 *
 * @param $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function drupal_content_sync_user_password_submit(&$form, FormStateInterface $form_state) {
  $uid = $form_state->getValue('uid');

  if (DRUPAL_CONTENT_SYNC_USER_ID == $uid) {
    $new_data = [
      'userName' => $form_state->getValue('name'),
      'userPass' => $form_state->getValue('pass'),
    ];

    // If password wasn't changed then value will be empty and we don't need it.
    $new_data = array_filter($new_data);
    $new_data = drupal_content_sync_encrypt_values($new_data);

    $userId   = $form_state->getValue('uid');
    $userData = \Drupal::service('user.data');

    $old_data = $userData->get('drupal_content_sync', $userId, 'sync_data');
    $new_data = array_replace($old_data, $new_data);

    $userData->set('drupal_content_sync', $userId, 'sync_data', $new_data);

    $synchronisations = DrupalContentSync::getAll();

    foreach ($synchronisations as $synchronisation) {
      $synchronisation->save();
    }
  }
}

/**
 * Encrypt the provided values. This is used to securely store the
 * authentication password necessary for API Unify to make changes.
 *
 * @param array $values
 *   The values to encrypt.
 *
 * @return array The input array, but with encrypted values.
 */
function drupal_content_sync_encrypt_values(array $values) {
  $encryption_profile = EncryptionProfile::load(DRUPAL_CONTENT_SYNC_PROFILE_NAME);

  foreach ($values as $key => $value) {
    $values[$key] = \Drupal::service('encryption')
      ->encrypt($value, $encryption_profile);
  }

  return $values;
}

/**
 * Disable all form elements if the content has been imported and the user
 * should not be able to alter imported content.
 *
 * @see \drupal_content_sync_form_alter()
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param string $form_id
 */
function _drupal_content_sync_form_alter_disabled_fields(&$form, FormStateInterface $form_state, $form_id) {
  $form_object = $form_state
    ->getFormObject();

  if (!($form_object instanceof ContentEntityForm)) {
    return;
  }

  if($form_object instanceof ContentEntityDeleteForm) {
    return;
  }

  $entity = $form_object
    ->getEntity();

  // @TODO Check why this is NULL in some cases
  if (!$entity) {
    return;
  }

  $meta_infos = \Drupal\drupal_content_sync\Entity\DrupalContentSyncMetaInformation::getInfoForEntity(
    $entity->getEntityTypeId(),
    $entity->uuid()
  );
  $behavior = NULL;
  $overridden = FALSE;
  foreach ($meta_infos as $info) {
    if(!$info || !$info->getLastImport() || $info->isCloned()) {
      continue;
    }
    if($info->isSourceEntity()) {
      continue;
    }
    $config = DrupalContentSync::load($info->getEntityTypeConfig())
    ->getEntityTypeConfig($entity->getEntityTypeId(),$entity->bundle());
    if ($config['import_updates']==DrupalContentSync::IMPORT_UPDATE_FORCE_AND_FORBID_EDITING ||
      $config['import_updates']==DrupalContentSync::IMPORT_UPDATE_FORCE_UNLESS_OVERRIDDEN) {
      $behavior = $config['import_updates'];
      $overridden = $info->isOverriddenLocally();
      break;
    }
  }

  if (!$behavior) {
    return;
  }

  $id = bin2hex(random_bytes(4));

  $allow_overrides = $behavior==DrupalContentSync::IMPORT_UPDATE_FORCE_UNLESS_OVERRIDDEN;

  $hide_elements = ['container','vertical_tabs','details'];
  foreach ($form as $key => $form_item) {
    if(!is_array($form_item))
      continue;
    if(!isset($form_item['#type']))
      continue;
    if (0 === strpos($key, 'field_') || in_array($form_item['#type'],$hide_elements)) {
      if($allow_overrides) {
        // If we used the DISABLED attribute, we couldn't reliably remove it
        // from all elements, as some should still have the attribute from other
        // circumstances and we would also have to apply it nested.
        // Otherwise we'd have to either submit the form and redirect to the
        // edit page or reload the whole form via AJAX, conflicting with
        // embedded forms.
        // So instead we hide and show the elements via JavaScript, leading
        // to the best usability and overall simplest / most reliable
        // implementation from the options available-
        $form[$key]['#attributes']['class'][] = 'dcs-edit-override-id-' . $id;
        if(!$overridden) {
          $form[$key]['#attributes']['class'][] = 'dcs-edit-override-hide';
        }
      }
      else {
        $form[$key]['#disabled'] = TRUE;
      }
    }
  }

  if($allow_overrides) {
    $form['dcs_edit_override'] = [
      '#type' => 'checkbox',
      '#default_value' => $overridden,
      '#weight' => -10000,
      '#title' => t('Overwrite locally and ignore future remote updates'),
      '#description' => t('%label has been imported and future remote updates would overwrite local changes. Checking this will make sure that future remote updates will be ignored so your local changes persist.',[
        '%label' => $entity->label(),
      ]),
      '#attributes' => [
        'class' => ['dcs-edit-override'],
        'data-dcs-edit-override-id' => $id,
      ],
    ];
    $form['#attached']['library'][] = 'drupal_content_sync/entity-form';
    $form['actions']['submit']['#submit'][] = '_drupal_content_sync_override_entity_submit';
  }
  else {
    $messenger = \Drupal::messenger();
    $messenger->addWarning(t('%label cannot be edited as it has been imported.',[
      '%label' => $entity->label(),
    ]));
  }
}

/**
 * Update the DrupalContentSyncMetaInformation for the given entity, setting
 * the DrupalContentSyncMetaInformation::FLAG_EDIT_OVERRIDE flag accordingly.
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function _drupal_content_sync_override_entity_submit(array $form, FormStateInterface $form_state) {
  $value = boolval($form_state->getValue('dcs_edit_override'));

  $entity = $form_state
    ->getFormObject()
    ->getEntity();

  $meta_infos = \Drupal\drupal_content_sync\Entity\DrupalContentSyncMetaInformation::getInfoForEntity(
    $entity->getEntityTypeId(),
    $entity->uuid()
  );
  foreach ($meta_infos as $info) {
    if (!$info || !$info->getLastImport() || $info->isCloned()) {
      continue;
    }
    $config = DrupalContentSync::load($info->getEntityTypeConfig())
      ->getEntityTypeConfig($entity->getEntityTypeId(), $entity->bundle());
    if ($config['import_updates'] == DrupalContentSync::IMPORT_UPDATE_FORCE_UNLESS_OVERRIDDEN) {
      if($value!=$info->isOverriddenLocally()) {
        $info->isOverriddenLocally($value);
        $info->save();
        // TODO: If changed to "Don't override", we should re-import the entity
        // from API Unify.
      }
      break;
    }
  }
}

/**
 * Implements hook_theme().
 */
function drupal_content_sync_theme() {
  $theme['drupal_content_sync_content_dashboard'] = [
    'variables' => ['configuration' => NULL],
    'template' => 'drupal_content_sync_content_dashboard',
  ];

  $theme['drupal_content_sync_introduction'] = [
    'variables' => [],
    'template' => 'drupal_content_sync_introduction',
  ];

  return $theme;
}

/**
 * Implements hook_entity_operation_alter().
 *
 * Provide "push changes" option.
 */
function drupal_content_sync_entity_operation_alter(array &$operations, EntityInterface $entity) {
  $operations += drupal_content_sync_get_publish_changes_operations($entity);
}

/**
 * Returns operations for "push changes" action.
 */
function drupal_content_sync_get_publish_changes_operations(EntityInterface $entity) {
  /** @var \Drupal\Core\Routing\RedirectDestinationInterface $redirect_destination */
  $redirect_destination = Drupal::service('redirect.destination');

  $sync = DrupalContentSync::getExportSynchronizationForEntity($entity, DrupalContentSync::EXPORT_MANUALLY);

  if (!$sync) {
    return [];
  }

  $route_parameters = [
    'sync_id' => $sync->id(),
    'entity_type' => $entity->getEntityTypeId(),
    'entity' => $entity->id(),
  ];

  $operations['publish_changes'] = [
    'title' => t('Push changes'),
    'weight' => 150,
    'url' => Url::fromRoute('drupal_content_sync.publish_changes', $route_parameters),
    'query' => $redirect_destination->getAsArray(),
  ];

  return $operations;
}

/**
 * Implements hook_form_menu_edit_form_alter().
 *
 * Provide "push changes" action link.
 */
function drupal_content_sync_form_menu_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $links = [];
  if (!empty($form['links']['links'])) {
    $links = Element::children($form['links']['links']);
  }
  foreach ($links as $link_key) {
    $link = $form['links']['links'][$link_key];

    /** @var \Drupal\menu_link_content\Plugin\Menu\MenuLinkContent $menu_link */
    $menu_link = $link['#item']->link;
    if (!method_exists($menu_link, 'getEntity')) {
      continue;
    }

    // We need to get an Entity at this point,
    // but 'getEntity' is protected for some reason.
    // So we don't have other choice here but use a reflection.
    $menu_link_reflection = new ReflectionMethod('\Drupal\menu_link_content\Plugin\Menu\MenuLinkContent', 'getEntity');
    $menu_link_reflection->setAccessible(TRUE);
    $menu_link_entity = $menu_link_reflection->invoke($menu_link, 'getEntity');

    $form['links']['links'][$link_key]['operations']['#links'] += drupal_content_sync_get_publish_changes_operations($menu_link_entity);
  }
}
