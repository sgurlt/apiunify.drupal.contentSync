<?php

/**
 * @file
 * Module file for drupal_content_sync.
 *
 * @author Edge Box GmbH
 */

use Drupal\Core\Entity\ContentEntityForm;
use Drupal\Core\Form\FormStateInterface;
use Drupal\drupal_content_sync\ExportIntent;
use Drupal\drupal_content_sync\ImportIntent;
use Drupal\drupal_content_sync\SyncIntent;
use Drupal\encrypt\Entity\EncryptionProfile;
use Drupal\Core\Entity\EntityInterface;
use Drupal\drupal_content_sync\Entity\Flow;
use Drupal\Core\Url;
use Drupal\Core\Render\Element;
use Drupal\Core\Entity\ContentEntityDeleteForm;
use Drupal\drupal_content_sync\Entity\MetaInformation;
use Drupal\drupal_content_sync\Entity\Pool;

/**
 * @var int DRUPAL_CONTENT_SYNC_USER_ID The user to perform updates with.
 */
define('DRUPAL_CONTENT_SYNC_USER_ID', \Drupal::service('keyvalue.database')->get('drupal_content_sync_user')->get('uid'));
/**
 * @var string DRUPAL_CONTENT_SYNC_PROFILE_NAME The encryption profile name.
 */
define('DRUPAL_CONTENT_SYNC_PROFILE_NAME', 'drupal_content_sync');

/**
 * 1) Make sure the user is informed that content will not only be deleted on
 * this * instance but also on all connected instances if configured that way.
 *
 * 2) Make sure API Unify knows about password changes at the
 * Drupal Content Sync user and can still authenticate to perform updates.
 *
 * 3) Disabled node forms if the content has been imported and the
 * synchronization is configured to disable imported content.
 *
 * @param array $form
 *   The form definition.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 * @param string $form_id
 *   he ID of the form.
 *
 * @see _drupal_content_sync_form_alter_disabled_fields
 */
function drupal_content_sync_form_alter(array &$form, FormStateInterface $form_state, $form_id) {
  $form_object = $form_state->getFormObject();

  if ($form_object instanceof ContentEntityDeleteForm) {
    if (!empty($form_state->getUserInput()['confirm'])) {
      return;
    }

    $entity = $form_object->getEntity();

    if (!Flow::isLocalDeletionAllowed($entity)) {
      $messenger = \Drupal::messenger();
      $messenger->addWarning(
        t(
          '%label cannot be deleted as it has been imported.',
          ['%label' => $entity->label()]
        )
      );
      // ['actions']['submit'].
      $form['#disabled'] = TRUE;
    }
    else {
      $flows = Flow::getFlowsForEntity(
        $entity,
        ExportIntent::EXPORT_AUTOMATICALLY,
        SyncIntent::ACTION_DELETE
      );
      if (!count($flows)) {
        $flows = Flow::getFlowsForEntity(
          $entity,
          ExportIntent::EXPORT_AS_DEPENDENCY,
          SyncIntent::ACTION_DELETE
        );
        if (count($flows)) {
          $infos = MetaInformation::getInfosForEntity(
            $entity->getEntityTypeId(),
            $entity->uuid()
          );
          $exported = [];
          foreach ($infos as $info) {
            if (!in_array($info->getFlow(), $flows)) {
              continue;
            }
            if (in_array($info->getFlow(), $exported)) {
              continue;
            }
            if (!$info->getLastExport()) {
              continue;
            }
            $exported[] = $info->getFlow();
          }
          $flows = $exported;
        }
      }

      if (count($flows)) {
        $messenger = \Drupal::messenger();
        $messenger->addWarning(
          t(
            'This will delete %label from all sites using it.',
            ['%label' => $entity->label()]
          )
        );
      }
    }
  }

  switch ($form_id) {
    case 'user_form':
      $form['actions']['submit']['#submit'][] = 'drupal_content_sync_user_password_submit';
      break;
  }

  _drupal_content_sync_form_alter_disabled_fields($form, $form_state, $form_id);

  // Add pool selection functionality to entity types.
  if ($form_object instanceof ContentEntityForm) {
    $entity = $form_object->getEntity();
    $bundle = $entity->bundle();
    $selectable_exportable_flows = Pool::getSelectablePools($entity->getEntityTypeId(), $bundle);

    if (!empty($selectable_exportable_flows)) {
      _drupal_content_sync_add_export_pool_form($form, $selectable_exportable_flows,$entity);
    }
  }
}

/**
 *
 */
function drupal_content_sync_field_widget_entity_reference_paragraphs_form_alter(&$element, &$form_state, $context) {

  // This code is based on:
  // https://www.drupal.org/project/paragraphs/issues/2868155#comment-12610258
  $entity_type = 'paragraph';
  $bundle = $element['#paragraph_type'];

  // If not bundle is given, the previous mentioned commit is
  // not added to the project.
  if (!is_null($bundle)) {
    $selectable_exportable_flows = Pool::getSelectablePools($entity_type, $bundle);

    if (!empty($selectable_exportable_flows)) {
      _drupal_content_sync_add_export_pool_form($element['subform'], $selectable_exportable_flows);
    }
  }
}

/**
 *
 */
function _drupal_content_sync_add_export_pool_form(&$form, $selectable_exportable_flows,$entity) {
  // Try to show the group right above the status checkbox if it exists.
  if (isset($form['status'])) {
    $weight = $form['status']['#weight'] - 1;
  }
  else {
    $weight = 99;
  }

  $form['dcs_export_group'] = [
    '#type' => 'details',
    '#open' => FALSE,
    '#title' => t('Export settings'),
    '#weight' => $weight,
  ];

  // If we got a advanced group we use it.
  if (isset($form['advanced'])) {
    $form['dcs_export_group']['#type'] = 'details';
    $form['dcs_export_group']['#group'] = 'advanced';
  }

  $selected_flow = NULL;

  // Flow selection.
  if (count($selectable_exportable_flows) === 1) {
    $id = array_keys($selectable_exportable_flows)[0];
    $form['dcs_export_group']['dcs_flow_selector'] = [
      '#title' => t('Export flow selection'),
      '#type' => 'hidden',
      '#value' => $id,
    ];
    $selected_flow  = Flow::getAll()[$id];
  }
  else {
    $flow_options = [];
    foreach ($selectable_exportable_flows as $flow_id => $selectable_exportable_flow) {
      if(!$selected_flow) {
        $selected_flow  = Flow::getAll()[$flow_id];
      }
      $flow_options[$flow_id] = $selectable_exportable_flow['flow_label'];
    }

    $form['dcs_export_group']['dcs_flow_selector'] = [
      '#title' => t('Export flow selection'),
      '#type' => 'select',
      '#default_value' => $selected_flow->id,
      '#options' => $flow_options,
      '#ajax' => [
        'callback' => '_drupal_content_sync_update_pool_selector',
        'event' => 'change',
        'wrapper' => 'ajax-pool-selector-wrapper',
      ],
    ];
  }

  // Pool selection.
  $options = $selectable_exportable_flows[$selected_flow->id];

  // Get configured widget type for the current active flow.
  if ($options['widget_type'] == 'single_select' || $options['widget_type'] == 'multi_select') {
    $widget_type = 'select';
  }
  else {
    $widget_type = $options['widget_type'];
  }

  $selected_pools = [];
  foreach($selected_flow->getUsedExportPools($entity,ExportIntent::EXPORT_AUTOMATICALLY,SyncIntent::ACTION_CREATE) as $pool) {
    $selected_pools[] = $pool->id;
  }

  $form['dcs_export_group']['dcs_pool_selector'] = [
    '#title' => t('Export pool selection'),
    '#prefix' => '<div id="ajax-pool-selector-wrapper">',
    '#suffix' => '</div>',
    '#type' => $widget_type,
    '#default_value' => $selected_pools,
    '#options' => $options['pools'],
  ];

  if ($options['widget_type'] == 'multi_select') {
    $form['dcs_export_group']['dcs_pool_selector']['#multiple'] = TRUE;
  }

  array_unshift($form['actions']['submit']['#submit'], '_drupal_content_sync_set_entity_export');
}

/**
 * Meta Information update.
 *
 * Update the MetaInformation for the given entity, setting
 * the MetaInformation::FLAG_EDIT_OVERRIDE flag accordingly.
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function _drupal_content_sync_set_entity_export(array $form, FormStateInterface $form_state) {
  $flow = $form_state->getValue('dcs_flow_selector');
  if(!$flow){
    return;
  }
  $flow   = Flow::getAll()[$flow];

  $values = $form_state->getValue('dcs_pool_selector');
  $pools  = Pool::getAll();

  /**
   * @var EntityInterface $entity
   */
  $entity = $form_state
    ->getFormObject()
    ->getEntity();

  foreach ($values as $pool_id=>$selected) {
    $pool = $pools[$pool_id];
    $meta = MetaInformation::getInfoForEntity($entity->getEntityTypeId(),$entity->uuid(),$flow,$pool);
    if(!$selected) {
      if($meta) {
        $meta->isExportEnabled(FALSE);
        $meta->save();
      }
      continue;
    }

    $meta = MetaInformation::getInfoForEntity($entity->getEntityTypeId(),$entity->uuid(),$flow,$pool);
    if(!$meta) {
      $meta = MetaInformation::create([
        'flow' => $flow->id,
        'pool' => $pool->id,
        'entity_type' => $entity->getEntityTypeId(),
        'entity_uuid' => $entity->uuid(),
        'entity_type_version' => Flow::getEntityTypeVersion($entity->getEntityTypeId(), $entity->bundle()),
        'flags' => 0,
        'source_url' => NULL,
      ]);
    }
    $meta->isExportEnabled(TRUE);
    $meta->save();
  }
}

/**
 * Ajax callback.
 */
function _drupal_content_sync_update_pool_selector(array $form, FormStateInterface $form_state) {
  $form_object = $form_state->getFormObject();
  /**
   * @var EntityInterface $entity
   */
  $entity = $form_object->getEntity();
  $bundle = $entity->bundle();
  $selectable_exportable_flows = Pool::getSelectablePools($entity->getEntityTypeId(), $bundle);

  $options = $selectable_exportable_flows[$form_state->getValue('dcs_flow_selector')]['pools'];
  $form['dcs_export_group']['dcs_pool_selector']['#options'] = $options;

  return $form['dcs_export_group']['dcs_pool_selector'];
}

/**
 * Export the entity automatically if configured to do so.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 */
function drupal_content_sync_entity_insert(EntityInterface $entity) {
  ExportIntent::exportEntityFromUi($entity, ExportIntent::EXPORT_AUTOMATICALLY, SyncIntent::ACTION_CREATE);
}

/**
 * Export the entity automatically if configured to do so.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 */
function drupal_content_sync_entity_update(EntityInterface $entity) {
  // This is actually an update, but for the case this entity existed
  // before the synchronization was created or the entity could not be
  // exported before for any reason, using ::ACTION_UPDATE would lead to
  // errors. Thus we're just using ::ACTION_CREATE which always works.
  ExportIntent::exportEntityFromUi($entity, ExportIntent::EXPORT_AUTOMATICALLY, SyncIntent::ACTION_UPDATE);
}

/**
 * Export the entity deletion automatically if configured to do so.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *
 * @throws \Exception If this entity has been imported and local deletion is
 *   forbidden, this will throw an error.
 */
function drupal_content_sync_entity_delete(EntityInterface $entity) {
  if (!Flow::isLocalDeletionAllowed($entity) &&
    !ImportIntent::entityHasBeenImportedByRemote($entity)) {
    throw new \Exception($entity->label() . ' cannot be deleted as it has been imported.');
  }

  ExportIntent::exportEntityFromUi($entity, ExportIntent::EXPORT_AUTOMATICALLY, SyncIntent::ACTION_DELETE);
}

/**
 * Implements hook_entity_translation_delete().
 */
function drupal_content_sync_entity_translation_delete(EntityInterface $translation) {
  ExportIntent::exportEntityFromUi($translation, ExportIntent::EXPORT_AUTOMATICALLY, SyncIntent::ACTION_DELETE_TRANSLATION);
}

/**
 * Update the password at API Unify if it's necessary for authentication.
 *
 * @param $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function drupal_content_sync_user_password_submit(&$form, FormStateInterface $form_state) {
  $uid = $form_state->getValue('uid');

  if (DRUPAL_CONTENT_SYNC_USER_ID == $uid) {
    $new_data = [
      'userName' => $form_state->getValue('name'),
      'userPass' => $form_state->getValue('pass'),
    ];

    // If password wasn't changed then value will be empty and we don't need it.
    $new_data = array_filter($new_data);
    $new_data = drupal_content_sync_encrypt_values($new_data);

    $userId   = $form_state->getValue('uid');
    $userData = \Drupal::service('user.data');

    $old_data = $userData->get('drupal_content_sync', $userId, 'sync_data');
    $new_data = array_replace($old_data, $new_data);

    $userData->set('drupal_content_sync', $userId, 'sync_data', $new_data);

    $flows = Flow::getAll();

    foreach ($flows as $flow) {
      $flow->save();
    }
  }
}

/**
 * Encrypt the provided values. This is used to securely store the
 * authentication password necessary for API Unify to make changes.
 *
 * @param array $values
 *   The values to encrypt.
 *
 * @return array The input array, but with encrypted values.
 */
function drupal_content_sync_encrypt_values(array $values) {
  $encryption_profile = EncryptionProfile::load(DRUPAL_CONTENT_SYNC_PROFILE_NAME);

  foreach ($values as $key => $value) {
    $values[$key] = \Drupal::service('encryption')
      ->encrypt($value, $encryption_profile);
  }

  return $values;
}

/**
 * Disable all form elements if the content has been imported and the user
 * should not be able to alter imported content.
 *
 * @see \drupal_content_sync_form_alter()
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param string $form_id
 */
function _drupal_content_sync_form_alter_disabled_fields(array &$form, FormStateInterface $form_state, $form_id) {
  $form_object = $form_state
    ->getFormObject();

  if (!($form_object instanceof ContentEntityForm)) {
    return;
  }

  if ($form_object instanceof ContentEntityDeleteForm) {
    return;
  }

  $entity = $form_object
    ->getEntity();

  // @TODO Check why this is NULL in some cases
  if (!$entity) {
    return;
  }

  $meta_infos = MetaInformation::getInfosForEntity(
    $entity->getEntityTypeId(),
    $entity->uuid()
  );
  $behavior = NULL;
  $overridden = FALSE;
  foreach ($meta_infos as $info) {
    if (!$info || !$info->getLastImport() || $info->isCloned()) {
      continue;
    }
    if ($info->isSourceEntity()) {
      continue;
    }
    $config = $info->getFlow()
      ->getEntityTypeConfig($entity->getEntityTypeId(), $entity->bundle());
    if ($config['import_updates'] == ImportIntent::IMPORT_UPDATE_FORCE_AND_FORBID_EDITING ||
      $config['import_updates'] == ImportIntent::IMPORT_UPDATE_FORCE_UNLESS_OVERRIDDEN) {
      $behavior = $config['import_updates'];
      $overridden = $info->isOverriddenLocally();
      break;
    }
  }

  if (!$behavior) {
    return;
  }

  $id = bin2hex(random_bytes(4));

  $allow_overrides = $behavior == ImportIntent::IMPORT_UPDATE_FORCE_UNLESS_OVERRIDDEN;

  // $hide_elements = ['container', 'vertical_tabs', 'details'];.
  foreach ($form as $key => $form_item) {
    if (!is_array($form_item)) {
      continue;
    }
    if (!isset($form_item['#type'])) {
      continue;
    }
    if ($key != 'actions') {
      if ($allow_overrides) {
        // If we used the DISABLED attribute, we couldn't reliably remove it
        // from all elements, as some should still have the attribute from other
        // circumstances and we would also have to apply it nested.
        // Otherwise we'd have to either submit the form and redirect to the
        // edit page or reload the whole form via AJAX, conflicting with
        // embedded forms.
        // So instead we hide and show the elements via JavaScript, leading
        // to the best usability and overall simplest / most reliable
        // implementation from the options available-.
        $form[$key]['#attributes']['class'][] = 'dcs-edit-override-id-' . $id;
        if (!$overridden) {
          $form[$key]['#attributes']['class'][] = 'dcs-edit-override-hide';
        }
      }
      else {
        $form[$key]['#disabled'] = TRUE;
      }
    }
  }

  if ($allow_overrides) {
    $form['dcs_edit_override'] = [
      '#type' => 'checkbox',
      '#default_value' => $overridden,
      '#weight' => -10000,
      '#title' => t('Overwrite locally and ignore future remote updates'),
      '#description' => t('%label has been imported and future remote updates would overwrite local changes. Checking this will make sure that future remote updates will be ignored so your local changes persist.', [
        '%label' => $entity->label(),
      ]),
      '#attributes' => [
        'class' => ['dcs-edit-override'],
        'data-dcs-edit-override-id' => $id,
      ],
    ];
    $form['#attached']['library'][] = 'drupal_content_sync/entity-form';
    $form['actions']['submit']['#submit'][] = '_drupal_content_sync_override_entity_submit';
  }
  else {
    $messenger = \Drupal::messenger();
    $messenger->addWarning(t('%label cannot be edited as it has been imported.', [
      '%label' => $entity->label(),
    ]));
  }
}

/**
 * Meta Information update.
 *
 * Update the MetaInformation for the given entity, setting
 * the MetaInformation::FLAG_EDIT_OVERRIDE flag accordingly.
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function _drupal_content_sync_override_entity_submit(array $form, FormStateInterface $form_state) {
  $value = boolval($form_state->getValue('dcs_edit_override'));

  /**
   * @var EntityInterface $entity
   */
  $entity = $form_state
    ->getFormObject()
    ->getEntity();

  $meta_infos = MetaInformation::getInfosForEntity(
    $entity->getEntityTypeId(),
    $entity->uuid()
  );
  foreach ($meta_infos as $info) {
    if (!$info || !$info->getLastImport() || $info->isCloned()) {
      continue;
    }
    $config = $info->getFlow()
      ->getEntityTypeConfig($entity->getEntityTypeId(), $entity->bundle());
    if ($config['import_updates'] == ImportIntent::IMPORT_UPDATE_FORCE_UNLESS_OVERRIDDEN) {
      if ($value != $info->isOverriddenLocally()) {
        $info->isOverriddenLocally($value);
        $info->save();
        // TODO: If changed to "Don't override", we should re-import the entity
        // from API Unify.
      }
      break;
    }
  }
}

/**
 * Implements hook_theme().
 */
function drupal_content_sync_theme() {
  $theme['drupal_content_sync_content_dashboard'] = [
    'variables' => ['configuration' => NULL],
    'template' => 'drupal_content_sync_content_dashboard',
  ];

  $theme['drupal_content_sync_introduction'] = [
    'variables' => [],
    'template' => 'drupal_content_sync_introduction',
  ];

  return $theme;
}

/**
 * Implements hook_entity_operation_alter().
 *
 * Provide "push changes" option.
 */
function drupal_content_sync_entity_operation_alter(array &$operations, EntityInterface $entity) {
  $operations += drupal_content_sync_get_publish_changes_operations($entity);
}

/**
 * Returns operations for "push changes" action.
 */
function drupal_content_sync_get_publish_changes_operations(EntityInterface $entity) {
  /** @var \Drupal\Core\Routing\RedirectDestinationInterface $redirect_destination */
  $redirect_destination = Drupal::service('redirect.destination');

  $flows = Flow::getFlowsForEntity($entity, ExportIntent::EXPORT_MANUALLY);

  if (!count($flows)) {
    return [];
  }

  foreach($flows as $flow) {
    $route_parameters = [
      'sync_id' => $flow->id(),
      'entity_type' => $entity->getEntityTypeId(),
      'entity' => $entity->id(),
    ];

    $operations['publish_changes'] = [
      'title' => t('Push changes'),
      'weight' => 150,
      'url' => Url::fromRoute('drupal_content_sync.publish_changes', $route_parameters),
      'query' => $redirect_destination->getAsArray(),
    ];
  }

  return $operations;
}

/**
 * Implements hook_form_menu_edit_form_alter().
 *
 * Provide "push changes" action link.
 */
function drupal_content_sync_form_menu_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $links = [];
  if (!empty($form['links']['links'])) {
    $links = Element::children($form['links']['links']);
  }
  foreach ($links as $link_key) {
    $link = $form['links']['links'][$link_key];

    /** @var \Drupal\menu_link_content\Plugin\Menu\MenuLinkContent $menu_link */
    $menu_link = $link['#item']->link;
    if (!method_exists($menu_link, 'getEntity')) {
      continue;
    }

    // We need to get an Entity at this point,
    // but 'getEntity' is protected for some reason.
    // So we don't have other choice here but use a reflection.
    $menu_link_reflection = new ReflectionMethod('\Drupal\menu_link_content\Plugin\Menu\MenuLinkContent', 'getEntity');
    $menu_link_reflection->setAccessible(TRUE);
    $menu_link_entity = $menu_link_reflection->invoke($menu_link, 'getEntity');

    $form['links']['links'][$link_key]['operations']['#links'] += drupal_content_sync_get_publish_changes_operations($menu_link_entity);
  }
}
