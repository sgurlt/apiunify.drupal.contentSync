<?php

/**
 * @file
 * Module file for drupal_content_sync.
 *
 * @author Edge Box GmbH
 */

use Drupal\drupal_content_sync\Exception\SyncException;
use Drupal\Core\Entity\ContentEntityForm;
use Drupal\Core\Form\FormStateInterface;
use Drupal\encrypt\Entity\EncryptionProfile;
use Drupal\Core\Entity\EntityInterface;
use Drupal\drupal_content_sync\Entity\DrupalContentSync;
use Drupal\Core\Url;
use Drupal\Core\Render\Element;
use Drupal\Core\Entity\ContentEntityDeleteForm;

/**
 * @var int DRUPAL_CONTENT_SYNC_USER_ID The user to perform updates with.
 */
define('DRUPAL_CONTENT_SYNC_USER_ID', \Drupal::service('keyvalue.database')->get('drupal_content_sync_user')->get('uid'));
/**
 * @var string DRUPAL_CONTENT_SYNC_PROFILE_NAME The encryption profile name.
 */
define('DRUPAL_CONTENT_SYNC_PROFILE_NAME', 'drupal_content_sync');

/**
 * 1) Make sure the user is informed that content will not only be deleted on
 * this * instance but also on all connected instances if configured that way.
 *
 * 2) Make sure API Unify knows about password changes at the
 * Drupal Content Sync user and can still authenticate to perform updates.
 *
 * 3) Disabled node forms if the content has been imported and the
 * synchronization is configured to disable imported content.
 *
 * @see _drupal_content_sync_form_alter_disabled_fields
 *
 * @param array $form
 *   The form definition.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param string $form_id
 *   he ID of the form.
 */
function drupal_content_sync_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form_object = $form_state->getFormObject();

  if ($form_object instanceof ContentEntityDeleteForm) {
    if (!empty($form_state->getUserInput()['confirm'])) {
      return;
    }

    $entity = $form_object->getEntity();
    $sync   = DrupalContentSync::getExportSynchronizationForEntity(
      $entity,
      DrupalContentSync::EXPORT_AUTOMATICALLY,
      DrupalContentSync::ACTION_DELETE
    );

    if ($sync) {
      $messenger = \Drupal::messenger();
      $messenger->addWarning(
        t(
          'This will delete %label from all sites using it.',
          ['%label' => $entity->label()]
        )
      );
    }
  }

  switch ($form_id) {
    case 'user_form':
      $form['actions']['submit']['#submit'][] = 'drupal_content_sync_user_password_submit';
      break;
  }

  _drupal_content_sync_form_alter_disabled_fields($form, $form_state, $form_id);
}

/**
 * Helper function to export an entity and display the user the results. If you
 * want to make changes programmatically, create your own handler instead.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity to export.
 * @param string $reason
 *   {@see DrupalContentSync::EXPORT_*}.
 * @param string $action
 *   {@see DrupalContentSync::ACTION_*}.
 * @param \Drupal\drupal_content_sync\Entity\DrupalContentSync $sync
 *   The sync to be used. First matching sync will be used if none is given.
 */
function _drupal_content_sync_export_entity(EntityInterface $entity, $reason, $action, DrupalContentSync $sync = NULL) {
  if (!$sync) {
    $sync = DrupalContentSync::getExportSynchronizationForEntity($entity, $reason, $action);
    if (!$sync) {
      return;
    }
  }

  $messenger = \Drupal::messenger();
  try {
    $status = $sync->exportEntity($entity, $reason, $action);

    if ($status) {
      $messenger->addMessage(t('%label has been exported with Drupal Content Sync.', ['%label' => $entity->label()]));
    }
  }
  catch (SyncException $e) {
    $message = $e->parentException ? $e->parentException->getMessage() : (
      $e->errorCode == $e->getMessage() ? '' : $e->getMessage()
    );
    if ($message) {
      $messenger->addWarning(t('Failed to export %label with Drupal Content Sync (%code). Message: %message', [
        '%label' => $entity->label(),
        '%code' => $e->errorCode,
        '%message' => $message,
      ]));
    }
    else {
      $messenger->addWarning(t('Failed to export %label with Drupal Content Sync (%code).', [
        '%label' => $entity->label(),
        '%code' => $e->errorCode,
      ]));
    }
  }
}

/**
 * Export the entity automatically if configured to do so.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 */
function drupal_content_sync_entity_insert(EntityInterface $entity) {
  _drupal_content_sync_export_entity($entity, DrupalContentSync::EXPORT_AUTOMATICALLY, DrupalContentSync::ACTION_CREATE);
}

/**
 * Export the entity automatically if configured to do so.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 */
function drupal_content_sync_entity_update(EntityInterface $entity) {
  // This is actually an update, but for the case this entity existed
  // before the synchronization was created or the entity could not be
  // exported before for any reason, using ::ACTION_UPDATE would lead to
  // errors. Thus we're just using ::ACTION_CREATE which always works.
  _drupal_content_sync_export_entity($entity, DrupalContentSync::EXPORT_AUTOMATICALLY, DrupalContentSync::ACTION_CREATE);
}

/**
 * Export the entity deletion automatically if configured to do so.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 */
function drupal_content_sync_entity_delete(EntityInterface $entity) {
  _drupal_content_sync_export_entity($entity, DrupalContentSync::EXPORT_AUTOMATICALLY, DrupalContentSync::ACTION_DELETE);
}

/**
 * Update the password at API Unify if it's necessary for authentication.
 *
 * @param $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function drupal_content_sync_user_password_submit(&$form, FormStateInterface $form_state) {
  $uid = $form_state->getValue('uid');

  if (DRUPAL_CONTENT_SYNC_USER_ID == $uid) {
    $new_data = [
      'userName' => $form_state->getValue('name'),
      'userPass' => $form_state->getValue('pass'),
    ];

    // If password wasn't changed then value will be empty and we don't need it.
    $new_data = array_filter($new_data);
    $new_data = drupal_content_sync_encrypt_values($new_data);

    $userId   = $form_state->getValue('uid');
    $userData = \Drupal::service('user.data');

    $old_data = $userData->get('drupal_content_sync', $userId, 'sync_data');
    $new_data = array_replace($old_data, $new_data);

    $userData->set('drupal_content_sync', $userId, 'sync_data', $new_data);

    $synchronisations = DrupalContentSync::getAll();

    foreach ($synchronisations as $synchronisation) {
      $synchronisation->save();
    }
  }
}

/**
 * Encrypt the provided values. This is used to securely store the
 * authentication password necessary for API Unify to make changes.
 *
 * @param array $values
 *   The values to encrypt.
 *
 * @return array The input array, but with encrypted values.
 */
function drupal_content_sync_encrypt_values(array $values) {
  $encryption_profile = EncryptionProfile::load(DRUPAL_CONTENT_SYNC_PROFILE_NAME);

  foreach ($values as $key => $value) {
    $values[$key] = \Drupal::service('encryption')
      ->encrypt($value, $encryption_profile);
  }

  return $values;
}

/**
 * Disable all form elements if the content has been imported and the user
 * should not be able to alter imported content.
 *
 * @see \drupal_content_sync_form_alter()
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param string $form_id
 */
function _drupal_content_sync_form_alter_disabled_fields(&$form, FormStateInterface $form_state, $form_id) {
  $form_object = $form_state
    ->getFormObject();

  if (!($form_object instanceof ContentEntityForm)) {
    return;
  }

  if($form_object instanceof ContentEntityDeleteForm) {
    return;
  }

  $entity = $form_object
    ->getEntity();

  // @TODO Check why this is NULL in some cases
  if (!$entity) {
    return;
  }

  $meta_infos = \Drupal\drupal_content_sync\Entity\DrupalContentSyncMetaInformation::getInfoForEntity(
    $entity->getEntityTypeId(),
    $entity->uuid()
  );
  $restrict = FALSE;
  foreach ($meta_infos as $info) {
    if(!$info || !$info->getLastImport() || $info->isCloned()) {
      continue;
    }
    $config = DrupalContentSync::load($info->getEntityTypeConfig())
    ->getEntityTypeConfig($entity->getEntityTypeId(),$entity->bundle());
    if (!empty($config['handler_settings']['restrict_editing'])) {
      $restrict = TRUE;
      break;
    }
  }

  if (!$restrict) {
    return;
  }

  foreach ($form as $key => $form_item) {
    if (0 === strpos($key, 'field_') || (is_array($form_item) && isset($form_item['#type']) && 'container' === $form_item['#type'])) {
      $form[$key]['#disabled'] = TRUE;
    }
  }
  $messenger = \Drupal::messenger();
  $messenger->addWarning(t('The entity cannot be edited because it has been synced.'));
}

/**
 * Implements hook_theme().
 */
function drupal_content_sync_theme() {
  $theme['drupal_content_sync_content_dashboard'] = [
    'variables' => ['configuration' => NULL],
    'template' => 'drupal_content_sync_content_dashboard',
  ];

  $theme['drupal_content_sync_introduction'] = [
    'variables' => [],
    'template' => 'drupal_content_sync_introduction',
  ];

  return $theme;
}

/**
 * Implements hook_entity_operation_alter().
 *
 * Provide "push changes" option.
 */
function drupal_content_sync_entity_operation_alter(array &$operations, EntityInterface $entity) {
  $operations += drupal_content_sync_get_publish_changes_operations($entity);
}

/**
 * Returns operations for "push changes" action.
 */
function drupal_content_sync_get_publish_changes_operations(EntityInterface $entity) {
  /** @var \Drupal\Core\Routing\RedirectDestinationInterface $redirect_destination */
  $redirect_destination = Drupal::service('redirect.destination');

  $sync = DrupalContentSync::getExportSynchronizationForEntity($entity, DrupalContentSync::EXPORT_MANUALLY);

  if (!$sync) {
    return [];
  }

  $route_parameters = [
    'sync_id' => $sync->id(),
    'entity_type' => $entity->getEntityTypeId(),
    'entity' => $entity->id(),
  ];

  $operations['publish_changes'] = [
    'title' => t('Push changes'),
    'weight' => 150,
    'url' => Url::fromRoute('drupal_content_sync.publish_changes', $route_parameters),
    'query' => $redirect_destination->getAsArray(),
  ];

  return $operations;
}

/**
 * Implements hook_form_menu_edit_form_alter().
 *
 * Provide "push changes" action link.
 */
function drupal_content_sync_form_menu_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $links = [];
  if (!empty($form['links']['links'])) {
    $links = Element::children($form['links']['links']);
  }
  foreach ($links as $link_key) {
    $link = $form['links']['links'][$link_key];

    /** @var \Drupal\menu_link_content\Plugin\Menu\MenuLinkContent $menu_link */
    $menu_link = $link['#item']->link;
    if (!method_exists($menu_link, 'getEntity')) {
      continue;
    }

    // We need to get an Entity at this point,
    // but 'getEntity' is protected for some reason.
    // So we don't have other choice here but use a reflection.
    $menu_link_reflection = new ReflectionMethod('\Drupal\menu_link_content\Plugin\Menu\MenuLinkContent', 'getEntity');
    $menu_link_reflection->setAccessible(TRUE);
    $menu_link_entity = $menu_link_reflection->invoke($menu_link, 'getEntity');

    $form['links']['links'][$link_key]['operations']['#links'] += drupal_content_sync_get_publish_changes_operations($menu_link_entity);
  }
}
